<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <title>W06d : KTX2 32bit Float Image Loader</title>
</head>
<body>
  <h2>KTX2 32bit Float Image Loader</h2>
  <input type="file" id="fileInput" accept=".ktx2" />
  <canvas id="glcanvas" width="512" height="512"></canvas>
  <div id="status"></div>
  <script type="module">
    import { read as ktxRead } from './ktx-parse.modern.js';

    const canvas = document.getElementById('glcanvas');
    const gl = canvas.getContext('webgl2');
    const status = document.getElementById('status');
    if (!gl) {
      status.textContent = 'WebGL2 not supported';
      throw new Error('WebGL2 not supported');
    }

    function showError(msg) {
      status.textContent = msg;
    }

  let animationFrameId = null;
  function renderKTX2(arrayBuffer) {
      let ktx;
      try {
        ktx = ktxRead(new Uint8Array(arrayBuffer));
      } catch (e) {
        showError('Failed to parse KTX2: ' + e);
        return;
      }
      if (!ktx.levels || !ktx.levels[0]) {
        showError('No valid texture data found.');
        return;
      }
      const level = ktx.levels[0];
      const tex = gl.createTexture();
      gl.bindTexture(gl.TEXTURE_2D, tex);
      // Assume RGBA32F for this loader
      let internalFormat = gl.RGBA32F;
      let format = gl.RGBA;
      let type = gl.FLOAT;
      // Check for float texture support
      const extColorBufferFloat = gl.getExtension('EXT_color_buffer_float');
      if (!extColorBufferFloat) {
        showError('EXT_color_buffer_float not supported: cannot display floating point textures.');
        return;
      }
      // Check for linear filtering support for float textures
      let useLinear = true;
      const floatLinear = gl.getExtension('OES_texture_float_linear');
      if (!floatLinear) {
        useLinear = false;
      }
      // Convert to Float32Array if needed
      let texData = level.levelData;
      if (!(texData instanceof Float32Array)) {
        texData = new Float32Array(texData.buffer, texData.byteOffset, texData.byteLength / 4);
      }
      gl.texImage2D(
        gl.TEXTURE_2D,
        0,
        internalFormat,
        ktx.pixelWidth,
        ktx.pixelHeight,
        0,
        format,
        type,
        texData
      );
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, useLinear ? gl.LINEAR : gl.NEAREST);
      gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, useLinear ? gl.LINEAR : gl.NEAREST);
      gl.activeTexture(gl.TEXTURE0);
      gl.bindTexture(gl.TEXTURE_2D, tex);

      // Shaders
      const vsSource = `#version 300 es\n
        in vec2 aPos;\n
        in vec2 aTex;\n
        out vec2 vTex;\n
        void main() {\n
          vTex = aTex;\n
          gl_Position = vec4(aPos, 0, 1);\n
        }`;
      const fsSource = `#version 300 es\n
        precision highp float;\n
        in vec2 vTex;\n
        uniform sampler2D uTex;\n        
        uniform float fade;\n
        out vec4 outColor;\n
        void main() {\n          
           outColor = texture(uTex, vTex) * fade;\n
        }`;
      function createShader(type, src) {
        const s = gl.createShader(type);
        gl.shaderSource(s, src);
        gl.compileShader(s);
        return s;
      }
      function createProgram(vs, fs) {
        const p = gl.createProgram();
        gl.attachShader(p, vs);
        gl.attachShader(p, fs);
        gl.linkProgram(p);
        return p;
      }
      const vs = createShader(gl.VERTEX_SHADER, vsSource);
      const fs = createShader(gl.FRAGMENT_SHADER, fsSource);
      const prog = createProgram(vs, fs);
      gl.useProgram(prog);
      const verts = new Float32Array([
        -1, -1, 1, 1,
         1, -1, 0, 1,
        -1,  1, 1, 0,
         1,  1, 0, 0
      ]);
      const buf = gl.createBuffer();
      gl.bindBuffer(gl.ARRAY_BUFFER, buf);
      gl.bufferData(gl.ARRAY_BUFFER, verts, gl.STATIC_DRAW);
      const aPos = gl.getAttribLocation(prog, 'aPos');
      const aTex = gl.getAttribLocation(prog, 'aTex');
      gl.enableVertexAttribArray(aPos);
      gl.vertexAttribPointer(aPos, 2, gl.FLOAT, false, 16, 0);
      gl.enableVertexAttribArray(aTex);
      gl.vertexAttribPointer(aTex, 2, gl.FLOAT, false, 16, 8);
      gl.uniform1i(gl.getUniformLocation(prog, 'uTex'), 0);

      // Animation for fade
      const fadeLoc = gl.getUniformLocation(prog, 'fade');
      let frame = 0;
      const totalFrames = 300;
      // Cancel previous animation if running
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
      }
      function animate() {
        const t = (frame % totalFrames) / (totalFrames - 1);
        const fade = Math.pow(64, 2 * t - 1); // log scale
        gl.clearColor(0,0,0,1);
        gl.clear(gl.COLOR_BUFFER_BIT);
        gl.uniform1f(fadeLoc, fade);
        gl.drawArrays(gl.TRIANGLE_STRIP, 0, 4);
        frame++;
        animationFrameId = requestAnimationFrame(animate);
      }
      animate();
      status.textContent = 'Texture loaded!';
    }

    document.getElementById('fileInput').addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;
      const reader = new FileReader();
      reader.onload = function(ev) {
        renderKTX2(ev.target.result);
      };
      reader.onerror = function() {
        showError('Failed to read file.');
      };
      reader.readAsArrayBuffer(file);
    });
  </script>
</body>
</html>
